# -*- coding: utf-8 -*-
"""Version_1_qisea.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/130Np1UskemJ7kwGwNVWd14Zkur9EN-c5
"""

# Install core dependencies
!pip install qiskit cirq pyquil pandas numpy matplotlib seaborn plotly dash networkx sympy

# Install Rust to support pyquil
!curl https://sh.rustup.rs -sSf | sh -s -- -y
!export PATH="$HOME/.cargo/bin:$PATH"

from qiskit import QuantumCircuit
import pandas as pd

def generate_ghz(n=3):
    qc = QuantumCircuit(n)
    qc.h(0)
    for i in range(n - 1):
        qc.cx(i, i + 1)
    return qc

circuits = []
for n in range(3, 6):
    qc = generate_ghz(n)
    data = {
        'name': f'GHZ_{n}',
        'num_qubits': qc.num_qubits,
        'depth': qc.depth(),
        'width': qc.width(),
        'total_gates': qc.size(),
        'cx_count': qc.count_ops().get('cx', 0)
    }
    circuits.append(data)

df = pd.DataFrame(circuits)
df.to_csv("compiled_circuits.csv", index=False)
df.head()

def compute_features(qc):
    return {
        "total_gates": qc.size(),
        "depth": qc.depth(),
        "num_qubits": qc.num_qubits,
        "cx_count": qc.count_ops().get('cx', 0),
        "t_count": qc.count_ops().get('t', 0),
        "h_count": qc.count_ops().get('h', 0),
    }

features = compute_features(generate_ghz(4))
features

import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv("compiled_circuits.csv")

sns.histplot(df['cx_count'])
plt.title("CX Gate Count Distribution")
plt.show()

sns.pairplot(df[['depth', 'total_gates', 'cx_count', 'num_qubits']])
plt.suptitle("EDA Pair Plot", y=1.02)
plt.show()

import qiskit
import cirq
from pyquil import Program
from pyquil.gates import H, CNOT

def compile_ghz_qiskit(n):
    qc = generate_ghz(n)
    transpiled = qiskit.transpile(qc)
    return {
        "compiler": "Qiskit",
        "depth": transpiled.depth(),
        "cx_count": transpiled.count_ops().get('cx', 0),
        "total_gates": transpiled.size(),
        "width": transpiled.width()
    }

def compile_ghz_cirq(n):
    qubits = [cirq.LineQubit(i) for i in range(n)]
    circuit = cirq.Circuit()
    circuit.append(cirq.H(qubits[0]))
    for i in range(n - 1):
        circuit.append(cirq.CNOT(qubits[i], qubits[i+1]))
    return {
        "compiler": "Cirq",
        "depth": len(circuit),
        "cx_count": sum(isinstance(op.gate, cirq.CNotPowGate) for op in circuit.all_operations()),
        "total_gates": len(list(circuit.all_operations())),
        "width": n
    }

def compile_ghz_pyquil(n):
    prog = Program()
    prog += H(0)
    for i in range(1, n):
        prog += CNOT(i-1, i)
    return {
        "compiler": "PyQuil",
        "depth": len(prog.instructions),
        "cx_count": str(prog).count("CNOT"),
        "total_gates": len(prog.instructions),
        "width": n
    }

results = []
for compiler in [compile_ghz_qiskit, compile_ghz_cirq, compile_ghz_pyquil]:
    for n in range(3, 6):
        results.append({**compiler(n), "circuit": f"GHZ_{n}"})

df_compiler = pd.DataFrame(results)
df_compiler.head()

import networkx as nx

G = nx.DiGraph()
G.add_edge("H", "CX_1")
G.add_edge("CX_1", "CX_2")
G.add_edge("CX_2", "Measure")

nx.draw(G, with_labels=True, node_color='skyblue', node_size=2000)
plt.title("Gate Flow Network (Demo)")
plt.show()

def alert_rules(qc):
    alerts = []
    if qc.count_ops().get('cx', 0) > qc.num_qubits * 2:
        alerts.append("⚠ High CX density — may reduce fidelity.")
    if qc.depth() > qc.num_qubits * 5:
        alerts.append("⚠ Deep circuit — consider optimization.")
    if qc.size() > 20:
        alerts.append("⚠ Circuit is large — optimize for hardware.")
    return alerts

print(alert_rules(generate_ghz(5)))

import plotly.express as px

px.bar(df_compiler, x="circuit", y="depth", color="compiler", barmode="group", title="Depth Comparison")

px.line(df_compiler, x="circuit", y="total_gates", color="compiler", markers=True, title="Total Gates by Compiler")

for circuit in df_compiler['circuit'].unique():
    subset = df_compiler[df_compiler['circuit'] == circuit]
    best = subset.sort_values(by="depth").iloc[0]
    print(f"For {circuit}, best compiler by depth is: {best['compiler']} (Depth = {best['depth']})")